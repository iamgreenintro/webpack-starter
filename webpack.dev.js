const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
// const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  // Specify the mode we want to run in:
  // 1. 'production', this is the default value when no mode is specified.
  // 2. 'development'.
  // 3. 'none', opts out of any default optimization options that come with either 'production' or 'development' mode.
  mode: 'development',

  // Our entry points from which webpack will build a dependency graph.
  // Basically checks for modules that each file depends on and builds application in that order.
  // See: https://webpack.js.org/concepts/dependency-graph/.
  // Each entry point's key is also it's chunk name and can be referenced as [name] within it's entry point scope.
  entry: {
    // Define our main entry point:
    main: {
      // When resolving the path to the entry file/module we load upon startup, it expects:
      // 1. You have this webpack configuration file in the root of your project's directory.
      // 2. You have a directory named 'src' inside of the root of your project's directory.
      // 3. Your entry script is inside of the above mentioned 'src' directory and is called 'index.js'.
      import: path.resolve(__dirname, 'src/index.js'),

      // The name of the bundled output file where:
      // 1. The [name] stands for 'main' as per the key above that resolves the path to our entry file.
      // 2. The [contenthash] is a changing hash allowing to bypass same-named cached files (which can lead to not seeing latest changes).
      // 3. When compiled will be named "main.5sdefdf100c94fd5efa81f.bundle.js", aside from the content hash changing.
      filename: '[name].[contenthash].bundle.js',

      // The runtime setting takes two possible values, being:
      // 1. false -> When generating it inline in the entry chunk we specified above.
      // 2. The file name as a string value, which represents the new runtime bundle it will generate.
      // We do not need it when using development mode and want to focus on fast builds, generating that extra runtime bundle adds time.
      runtime: false,
    },
    // Creating a js module for our styles to automatically bundle into a chunk.
    // We could also import it in our 'main' entry point (index.js) but I prefer to split our styling and javascript.
    styles: {
      import: path.resolve(__dirname, 'src/styles/main.scss'),
      filename: '[name].[contenthash].bundle.js',
      runtime: false,
    },
  },

  // Our output settings will define how and where webpack generates our bundled files.
  // By default webpack generates a 'dist' folder and puts the bundled chunks inside of it.
  output: {
    // Our output directory will (still) be 'dist', the folder will be generated by webpack.
    path: path.resolve(__dirname, 'dist'),

    // Name of our bundled output file where [name] represents our entry point name.
    // In this example: main.5sdefdf100c94fd5efa81f.bundle.js
    // The content hash changes forcing to reload the newly-named file instead of pulling the same-named cached version.
    filename: '[name].[contenthash].bundle.js',

    // Keep the asset's original source name and extension (so the asset's file name still matches with it's path).
    assetModuleFilename: '[name][ext]',

    // Allow chunks to be loaded on demand (asynchronously).
    // This will load entry points asynchronously as soon as they are needed (runtime).
    // Think of a web application with multiple pages/routes which are index points for those pages.
    // They only get loaded once that page is invoked.
    asyncChunks: true,

    // Tells Webpack to check if to be emitted file already exists and has the same content before writing to the output file system.
    // When set to `true`; Webpack will not write output file if it already exists on the disk.
    // The issue with setting it to `true` is that it will increase build time since it's first going to compare each file.
    // For `development` mode I prefer to prioritize speed for productivity.
    compareBeforeEmit: false,

    // Clean up the dist folder before generating a new build so it doesn't pile up.
    clean: true,
  },
  plugins: [
    new HtmlWebpackPlugin({
      title: 'Webpack App',
      filename: 'index.html',
      template: path.resolve(__dirname, 'src/index.html'),
    }),
    // new MiniCssExtractPlugin(),
  ],
  module: {
    rules: [
      // Rules that are matched and then apply loaders or modify the parser.
      // For more information: https://webpack.js.org/configuration/module/#rule

      {
        test: /\.html$/,
        use: ['html-loader'],
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: [],
      },

      // Add loaders for the following file types: ".css", ".scss" and ".sass".
      // The order in this case is important; "style-loader" must come first, followed by "css-loader".
      // You could swap out the 'style-loader' for the `MiniCssExtractPlugin.loader` plugin.
      {
        test: /\.(css|scss|sass)$/i,
        exclude: /node_modules/,
        use: ['style-loader', 'css-loader', 'sass-loader'],
      },

      // Handling image/gif type assets:
      // Having these image/gif file types without the loader will crash the application.
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        type: 'asset/resource',
      },

      // Handling font type assets:
      // Having these font file types without the loader will crash the application.
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/i,
        type: 'asset/resource',
      },
    ],
  },
};
