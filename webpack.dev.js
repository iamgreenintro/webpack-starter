const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
// const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  // Specify the mode we want to run in:
  // 1. 'production', this is the default value when no mode is specified.
  // 2. 'development'.
  // 3. 'none', opts out of any default optimization options that come with either 'production' or 'development' mode.
  mode: 'development',

  // Our entry points from which webpack will build a dependency graph.
  // Basically checks for modules that each file depends on and builds application in that order.
  // See: https://webpack.js.org/concepts/dependency-graph/.
  // Each entry point's key is also it's chunk name and can be referenced as [name] within it's entry point scope.
  entry: {
    // Define our main entry point:
    main: {
      // When resolving the path to the entry file/module we load upon startup, it expects:
      // 1. You have this webpack configuration file in the root of your project's directory.
      // 2. You have a directory named 'src' inside of the root of your project's directory.
      // 3. Your entry script is inside of the above mentioned 'src' directory and is called 'index.js'.
      import: path.resolve(__dirname, 'src/index.js'),

      // The name of the bundled output file where:
      // 1. The [name] stands for 'main' as per the key above that resolves the path to our entry file.
      // 2. The [contenthash] is a changing hash allowing to bypass same-named cached files (which can lead to not seeing latest changes).
      // 3. When compiled will be named "main.5sdefdf100c94fd5efa81f.bundle.js", aside from the content hash changing.
      filename: 'js/[name].[contenthash].bundle.js',

      // The runtime setting takes two possible values, being:
      // 1. false -> When generating it inline in the entry chunk we specified above.
      // 2. The file name as a string value, which represents the new runtime bundle it will generate.
      // We do not need it when using development mode and want to focus on fast builds, generating that extra runtime bundle adds time.
      runtime: false,
    },
    // Creating a js module for our styles to automatically bundle into a chunk.
    // We could also import it in our 'main' entry point (index.js) but I prefer to split our styling and javascript.
    styles: {
      import: path.resolve(__dirname, 'src/styles/main.scss'),
      filename: 'css/[name].[contenthash].bundle.js',
      runtime: false,
    },
  },

  // Our output settings will define how and where webpack generates our bundled files.
  // By default webpack generates a 'dist' folder and puts the bundled chunks inside of it.
  output: {
    // Our output directory will (still) be 'dist', the folder will be generated by webpack.
    path: path.resolve(__dirname, 'dist'),

    // Name of our bundled output file where [name] represents our entry point name.
    // In this example: main.5sdefdf100c94fd5efa81f.bundle.js
    // The content hash changes forcing to reload the newly-named file instead of pulling the same-named cached version.
    filename: '[name].[contenthash].bundle.js',

    // Add a directory called `assets` for our asset files being output.
    // Files will contain the original name with a contenthash followed by the original extension.
    assetModuleFilename: 'assets/[name].[contenthash][ext]',

    // Allow chunks to be loaded on demand (asynchronously).
    // This will load entry points asynchronously as soon as they are needed (runtime).
    // Think of a web application with multiple pages/routes which are index points for those pages.
    // They only get loaded once that page is invoked.
    asyncChunks: true,

    // Tells Webpack to check if to be emitted file already exists and has the same content before writing to the output file system.
    // When set to `true`; Webpack will not write output file if it already exists on the disk.
    // The issue with setting it to `true` is that it will increase build time since it's first going to compare each file.
    // For `development` mode I prefer to prioritize speed for productivity.
    compareBeforeEmit: false,

    // Clean up the output folder before generating a new build so it doesn't pile up.
    clean: true,
  },

  // The `devtool` option controls if and how source maps are generated.
  // Source maps essentially allow us to debug our code that's been compressed.
  // https://webpack.js.org/configuration/devtool/#devtool
  devtool: 'eval-cheap-module-source-map',

  // Our development server settings:
  // This is the webpack-dev-server and is used instead of the webpack `--watch` flag.
  // The upside of using the webpack-dev-server is it auto-refreshing the browser on changes (live reloading).
  devServer: {
    // Hosts that are allowed to communicate with the development server.
    // 'auto' allows 'localhost' 'host' and a webSocketURL by default.
    allowedHosts: 'auto',

    // Directory to serve from memory:
    static: {
      directory: path.resolve(__dirname, 'dist'),
    },

    // If we're going to use multiple entry points on a single HTML page, optimization.runtimeChunk: 'single' is needed too.
    // Otherwise we could get into trouble described here: https://bundlers.tooling.report/code-splitting/multi-entry/#webpack
    // Prevents creating multiple instances of the same module at runtime.
    runtimeChunk: 'single',

    splitChunks: {
      // Separate the third party dependencies into chunks for caching:
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    },

    // Port to run the development server on. Defaults to `8080`.
    port: 3000,

    // Automatically open the browser on the given port value (same as running webpack serve with `--open` flag).
    open: true,

    // Hot Module Replacement. On = true, off = false. It's set to true by default.
    hot: true,

    // Enable gzip compression to save bandwidth.
    // Read more about gzip compression here: https://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/
    // You can see if this actually works by checking the response header on one of your chunk files.
    // It should have `Content-Encoding: gzip`.
    compress: true,

    // Visiting a non-existing page will result in a 404 error.
    // We can redirect to the index.html by setting `historyApiFallback` to `true`.
    // http://localhost:3000/fdsklsdfmsklsdmskl will now still render index.html instead.
    historyApiFallback: true,
  },
  plugins: [
    new HtmlWebpackPlugin({
      title: 'Webpack Starter Project',
      filename: 'index.html',
      template: path.resolve(__dirname, 'src/index.html'),
    }),
    // new MiniCssExtractPlugin(),
  ],
  module: {
    rules: [
      // Rules that are matched and then apply loaders or modify the parser.
      // For more information: https://webpack.js.org/configuration/module/#rule

      {
        test: /\.html$/,
        use: ['html-loader'],
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: [],
      },

      // Add loaders for the following file types: ".css", ".scss" and ".sass".
      // The order in this case is important; "style-loader" must come first, followed by "css-loader".
      // You could swap out the 'style-loader' for the `MiniCssExtractPlugin.loader` plugin.
      {
        test: /\.(css|scss|sass)$/i,
        exclude: /node_modules/,
        use: ['style-loader', 'css-loader', 'sass-loader'],
      },

      // Handling image/gif type assets:
      // Having these image/gif file types without the loader will crash the application.
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        type: 'asset/resource',
      },

      // Handling font type assets:
      // Having these font file types without the loader will crash the application.
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/i,
        type: 'asset/resource',
      },
    ],
  },
};
